Tato kapitola se zabývá samotnou realizací platformy pro měření odpracovaného času. Popisuje nástroje použité během vývoje, strukturu zdrojového kódu a nakonec implementaci jednotlivých navržených funkcionalit aplikace.

%---------------------------------------------------------------
\section{Nástroje pro vývoj}
%---------------------------------------------------------------

Jak bylo navrženo v~sekci \ref{dev-tools}, pro nativní aplikaci bylo použito vývojové prostředí \emph{Xcode}. Verze tohoto IDE, na kterém byla implementace vyvíjena, byla 15.2. S~touto verzí IDE se pojí verze programovacího jazyku \emph{Swift} 5.9.2. Aplikace byla vyvíjena na operačním systému \emph{macOS Sonoma} (14.4). Nativní aplikace bude definovat minimální iOS verzi cílové platformy na verzi 17.0, jelikož tato verze umožňuje použití nejnovějších nástrojů platformy iOS. Podle dat z~února 2024 už tuto nejnovější verzi operačního systému používalo 66\% ze všech aktivních uživatelů mobilních telefonů iPhone. Mezi zařízeními představených v~předchozích čtyřech letech je to dokonce 76\% \cite{ios-17-adoption}.

Vývojové prostředí pro multi-platformní část a backend také dodržuje návrh ze sekce \ref{dev-tools}, bylo tedy použito \emph{IntelliJ IDEA}, verze 2024.1. Pro jazyk \emph{Kotlin} byla použita verze 1.9.10. 

\emph{Git} repozitář byl zálohován nástrojem \emph{GitHub} \cite{github}. Během vývoje nebyly použity žádné větve ani další nástroje pro týmovou spolupráci v~nástroji \emph{Git}, jelikož nikdo další na projektu nespolupracoval. Veškerý vývoj tedy probíhal přímo v~hlavní větvi \emph{main}.

%---------------------------------------------------------------
\subsection{Firebase}
%---------------------------------------------------------------

V~nástroji \emph{Firebase}, který byl vybrán v~návrhu v~sekci \ref{platform-architecture}, byl vytvořen projekt pro aplikaci Trackee. Byly vytvořeny tři prostředí – Alpha, Beta a Produkce. V~projektu zatím byly nastaveny funkce pro autentizaci a \emph{Firestore} databázi. 

\emph{Firebase} autentizace podporuje různé formy autentizace, jako e-mail s~heslem, ale třeba také přihlášení přes Google, přes Apple, přes Facebook a podobně. Rozšíření možností přihlášení by mohlo být podnětem pro budoucí vývoj aplikace, v~této fázi je zatím implementováno pouze přihlášení přeš e-mail a heslo. 

Při tvorbě \emph{Firestore} databáze \emph{Firebase} nabízí výběr, kde se má instance databáze nacházet (západní Evropa nebo Severní Amerika). Byla vybrána nejbližší možnost, tedy západní Evropa.

%---------------------------------------------------------------
\subsection{Nasazení backendu}
%---------------------------------------------------------------

Během vývoje byla aplikace backendu spouštěna a testována na lokálním stroji. V~místních sítích se tedy stačilo připojovat pomocí IP adresy počítače, na kterém aplikace backendu běžela, přes protokol HTTP, například: \texttt{http://192.168.88.70:8080}

Pro umožnění používání aplikace kdekoli, kdykoli a bez potřeby na lokálním stroji neustále ručně spouštět aplikaci backendu, bylo vhodné vybrat nějaké řešení, které by umožnilo nasazení aplikace backendu. K~tomu existuje řada externích poskytovatelů. Pro potřeby tohoto projektu byl zvolen nástroj \emph{Railway} \cite{railway}, jelikož zdarma nabízí počáteční kredit v~hodnotě pěti amerických dolarů, což by mělo na nějakou dobu vystačit pro potřeby vývoje aplikace. Tomuto nástroji pouze stačí propojení s~\emph{GitHub} repozitářem, nastavení skriptu pro spuštění a je hotovo. Nástroj poté při každé aktualizaci repozitáře sestaví projekt, spustí backend a nasadí ho na URL adrese \texttt{https://trackee-app-production.up.railway.app}. 

\emph{Railway} také podporuje automatické uspávání aplikace, které může snížit využívání kreditu v~době, kdy aplikace není využívána \cite{railway-app-sleeping}. Pokud se tedy aplikace nějakou dobu nepoužívá, je potřeba počítat s~několika sekundovou prodlevou při prvním požadavku.

Jednou nevýhodou nástroje \emph{Railway} ale je, že v~bezplatné variantě nabízí umístění stroje, na kterém běží instance, pouze ve státě Oregon ve Spojených státech amerických. Jelikož je to v~podstatě na druhé straně Země, vzniká tím poměrně znatelná prodleva mezi klientem a serverem. A v~kombinaci s~tím, že při nastavení nástroje \emph{Firebase} bylo zvoleno umístění instance v~Evropě (a toto umístění není možné po nastavení nástroje změnit), vznikají tím hlavně prodlevy při komunikaci s~databází, protože nyní musí backend každý požadavek na čtení nebo zápis dat posílat zhruba 8 tisíc kilometrů daleko. Rozdíl mezi používáním instance backendu běžící pomocí nástroje \emph{Railway} a používáním lokální instance je znatelný – například přihlášení a načtení hlavní obrazovky včetně plné počáteční stránky historie záznamů (10 záznamů) trvá 5-7 sekund, zatímco při použití lokální instance toto trvá 2-3 sekundy.

%---------------------------------------------------------------
\section{Architektura a struktura projektu}
%---------------------------------------------------------------

Jako šablona celého projektu sloužil \emph{DevStack} společnosti \emph{Matee} \cite{matee-devstack}, ze kterého byla odstraněna většina implementovaných funkcionalit a jejich balíčků, kromě těch, které se hodilo znovu využít (onboarding, profil, \dots). Ze šablony byly také ponechány nástroje na síťovou komunikaci (síťový klient pomocí knihovny \emph{Ktor} \cite{ktor}), interoperabilitu a další. V~šabloně také byly ponechány některé nástroje, které zatím projektem nejsou využívány, ale v~budoucnu při dalším rozvoji aplikace by se mohly hodit, jako nástroje pro práci s~lokálním úložištěm \emph{SQLdelight}, \emph{UserDefaults} nebo \emph{Keychain}, nebo \emph{Providers} pro obsluhu GPS, obsluhu notifikací, a další. Jelikož Aplikace Trackee neimplementuje Android klienta, je celý jeho modul ze šablony odstraněn.

Aplikace implementuje tři prostředí – Alpha, Beta a Produkce. Zvykem bývá, že Alpha má vlastní instanci databáze a serveru, která slouží pouze pro testování a ladění, například při nasazování nových verzí backendu, a podobně. Beta na tom je pak obvykle podobně, ale buď duplikuje data z~produkčního prostředí (ale přímo ho nemůže ovlivňovat), nebo je na produkční prostředí přímo napojena, ale nabízí nějaké přidané ladící možnosti. Produkční prostředí pak poskytuje databázi a server, které jsou využívány reálnými uživateli, kde je priorita orientována spíše na rychlost, než na možnosti ladění. Během vývoje aplikace Trackee nebylo potřeba využívat více instancí databáze nebo serveru, protože na projektu nepracuje více lidí, nevznikají konflikty a není zatím využíván reálnými uživateli. Prostředí se tedy liší jenom v~drobnostech, jako například v~tom, že Alpha a Beta nabízí rozšířené možnosti zachycování a přepisování požadavků na backend, nebo poskytuje detailnější popisy chybových hlášek, které mohou obsahovat více technických informací. 

Multi-platformní část a backend používají automatizační sestavovací nástroj \emph{Gradle} \cite{gradle}, což je populární nástroj pro flexibilní konfiguraci a automatizaci sestavování softwarových projektů. Nativní iOS aplikace používá pro sestavení nástroj \emph{xcodebuild}, který je součástí \emph{Xcode} IDE. Multi-platformní knihovna je do nativní iOS aplikace propagována jako knihovna typu \emph{xcframework}, což je \emph{multiplatformní binární framework} \cite{xcframework}. \emph{Gradle} zkompiluje multi-platformní kód do této \emph{xcframework} reprezentace a zkopíruje ji do iOS projektu.

Všechny části implementace (nativní aplikace, multi-platformní část a backend) jsou součástí jednoho repozitáře (\emph{monorepo}), který má následující strukturu:
\begin{itemize}
\item\texttt{backend} – modul obsahující projekt backendu
\item\texttt{build-logic} – společný modul ostatních modulů, obsahující pluginy a nástroje pro sestavení multi-platformní knihovny
\item\texttt{gradle} - složka pro soubory nástroje \emph{Gradle}
\item\texttt{ios} – složka obsahující projekt nativní iOS aplikace
\item\texttt{other} – nástroje projektu
\item\texttt{shared} – modul obsahující sdílený kód pro technologii \emph{Kotlin Multiplatform}
\item\texttt{twine} – složka obsahující lokalizační soubor
\end{itemize}
Jednotlivé části implementace poté dodržují architekturu navrženou v~sekci \ref{platform-architecture}.

%---------------------------------------------------------------
\subsection{Lokalizace}
%---------------------------------------------------------------

Aplikace byla implementována a lokalizována pro tři jazyky – čeština, slovenština a angličtina. Texty pro veškeré lokalizace (tlačítka, popisky, instrukce, \dots) jsou uloženy v~souboru \texttt{strings.txt} ve složce \texttt{twine}, který je připraven ve formátu pro nástroj \emph{Twine} \cite{twine}, který tento soubor zpracovává a tvoří z~něj lokalizační soubory pro cílové platformy (pro iOS jsou to soubory \texttt{Localizable.strings}). Nastavení tohoto nástroje pro tyto jazyky je již v~šabloně \emph{DevStack} připraveno.

%---------------------------------------------------------------
\subsection{Automatické generování kódu}
%---------------------------------------------------------------

Šablona také používá několik pomocných nástrojů pro automatické generování kódu. Jedním takovým nástrojem je \emph{SwiftGen} \cite{swiftgen}, který zde slouží k~několika účelům:
\begin{itemize}
\item Generování struktur pro lokalizaci: \emph{SwiftGen} podle šablon generuje statické struktury z~lokalizačních souborů \texttt{Localizable.strings} pro jednodušší použití v~kódu, které zamezí použití špatných klíčů lokalizací.
\item Generování struktur pro obrázky: \emph{SwiftGen} je v~šabloně nastaven takovým způsobem, aby ze zdrojů \texttt{Images.xcassets} generoval statické struktury, které umožní jednodušší referencování obrázků ze zdrojového kódu.
\item Generování struktur pro barvy: Funguje stejným způsobem, jako obrázky.
\end{itemize}
Nástroj \emph{SwiftGen} je v~šabloně přidán jako \emph{plugin} modulu \emph{UIToolkit} v~prezentační vrstvě.

Nativní iOS aplikace také v~šabloně využívá makra \emph{swift-spyable} \cite{swift-spyable} \emph pro generování \emph{Use Case Mocks}, tedy statických náhrad pro \emph{Use Cases} používaných pro testování. Toto je ale používáno jen pro nativní \emph{Use Cases}, které aplikace Trackee neobsahuje. Pro sdílené \emph{Use Cases} je využíváno vlastních rodičovských tříd \texttt{UseCaseResultMock}, \texttt{UseCaseResultNoParamsMock}, atd.

%---------------------------------------------------------------
\subsection{Dependency Injection}
%---------------------------------------------------------------

Pro \emph{Dependency Injection} v~nativní aplikaci je využíváno knihovny \emph{Factory} \cite{factory}, v~multi-platformní části a na backendu knihovny \emph{Koin} \cite{koin}. V~aplikaci Trackee jsou sice všechny \emph{Use Cases} a \emph{Repositories} v~multi-platformní části, ale \emph{Dependency Injection} v~prezentační vrstvě nativní aplikace získává implementace sdílených \emph{Use Cases} knihovnou \emph{Factory}, aby bylo dosazování sjednocené s~případnými nativními \emph{Use Cases}. \emph{Dependency Injection} v~nativní aplikaci tedy funguje tak, že v~modulu \emph{DependencyInjection} v~aplikační vrstvě se registrují implementace všech závislostí, včetně sdílených \emph{Use Cases}, které ale poskytuje knihovna \emph{Koin}.

%---------------------------------------------------------------
\section{Implementace jednotlivých funkcionalit}
%---------------------------------------------------------------

Tato sekce se věnuje implementaci jednotlivých funkcionalit navržených v~sekci \ref{features}. Implementaci každé funkcionality rozebírá z~hlediska její realizace v~backendové části, v~multi-platformní části a v~nativní aplikaci.

%---------------------------------------------------------------
\subsection{Přihlášení a registrace}
%---------------------------------------------------------------

Přihlášení a registrace je základní funkcionalitou, kterou aplikace potřebuje, aby mohla držet informace o~konkrétním uživateli. V~návrhu platformy (obrázek \ref{fig:architecture}) byla autentizace navržena tak, že bude probíhat přes backend. Ale vzhledem k~tomu, že \emph{Firebase} autentizace nabízí více možností autentizace, jako přihlášení přes Apple, Google, a podobně, tak byl v~implementaci zvolen přístup, že autentizace bude probíhat na straně klienta, a ne backendu, protože jí celou obstará \emph{Firebase} autentizace. Bylo by sice možné provádět autentizace přes e-mail a heslo tak, že by klient poslal danou kombinaci e-mailu a hesla na backend, který by uživatele přes \emph{Firebase} přihlásil, klientovi vrátil jeho \emph{access token}\footnote{\emph{Access token} je v~autentizační terminologii řetězec znaků, se kterým klient posílá požadavky na server, aby prokázal svou identitu. \cite{access-token}}, který by ho poté dále používal při následujících požadavcích. V~případě rozšíření o~další formy přihlášení, jako je přihlášení přes Apple, by v~tomto přístupu musel \emph{Firebase} provést autentizaci u~klienta, získat mezistavový \emph{token} pro daného poskytovatele přihlášení, poslat ho na backend, který by ho poté ověřil s~autentizací \emph{Firebase}, získal \emph{access token}, a poslal ho klientovi. Vzhledem k~tomu, že takto by se autentizační API muselo volat jak u~klienta, tak na backendu, byl zvolen přístup, že celý tento proces se bude dít u~klienta pomocí knihovny pro \emph{Firebase} autentizaci, a na backend se bude ve všech možnostech přihlášení posílat jen \emph{access token}. V~případě, že by v~budoucnu padlo rozhodnutí tuto metodiku změnit a implementovat autentizační procesy pouze na backendu, musela by se tedy implementovat metodika popsaná výše.

%---------------------------------------------------------------
\subsubsection{Backend}
%---------------------------------------------------------------

Jak již bylo popsáno, backendová část nebude implementovat celý autentizační proces, ale jen bude ověřovat platnost \emph{access tokenu}. To bylo naimplementováno pomocí kofigurace bezpečnosti knihovny \emph{Ktor}. Pro všechny \emph{Routes}, tedy \emph{Endpoints}, které jsou definovány vnořeně ve funkci \texttt{authenticate}, se bude ověřovat, zda požadavek ve hlavičce obsahuje \emph{Bearer token} (\emph{access token}), ověří se přes \emph{Firebase} autentizaci pomocí funkce \texttt{verifyIdTokenAsync}, poté se získá uživatel pomocí \texttt{uid} a dále budou moct \emph{Routes} pracovat přímo s~informacemi o~přihlášeném uživateli. Průběh verifikace \emph{access tokenu} lze vidět v~ukázce kódu \ref{code:access-token-verification}. V~ukázce kódu \ref{code:ktor-security-config} lze poté vidět, jak bude backend získávat objekt úspěšně ověřeného uživatele. Pokud je uživatel úspěšně ověřen, ale nemá záznam v~databázi, bude mu tento záznam automaticky vytvořen – toto se bude dít při registraci uživatele.

\begin{listing}
\caption{Průběh verifikace \emph{access tokenu}}\label{code:access-token-verification}
\begin{minted}{Kotlin}
class FirebaseAuthProvider(config: Config) : AuthenticationProvider(config) {

    // ...
    
    override suspend fun onAuthenticate(context: AuthenticationContext) {
        val authHeader = context.call.request.parseAuthorizationHeader() 
            as? HttpAuthHeader.Single ?: throw AuthException.Unauthorized

        val token = try {
            firebase.verifyIdTokenAsync(authHeader.blob).await()
        } catch (e: FirebaseAuthException) {
            throw AuthException.InvalidToken(e)
        }

        val user = firebase.getUserAsync(token.uid).await()

        context.principal(FirebasePrincipal(user))

        val principal = context.mapPrincipal(user)
        if (principal != null) context.principal(principal)
    }
    
    // ...
}

fun AuthenticationConfig.firebase(
    name: String? = null,
    configure: FirebaseAuthProvider.Config.() -> Unit
) {
    val provider = FirebaseAuthProvider.Config(name).apply(configure).build()
    register(provider)
}
\end{minted}
\end{listing}

\begin{listing}
\caption{Konfigurace bezpečnosti knihovny \emph{Ktor}}\label{code:ktor-security-config}
\begin{minted}{Kotlin}
fun Application.configureSecurity() {
    
    // ...
    
    authentication {
        firebase {
            firebase = firebaseAuth
            mapPrincipal { userRecord ->
                userRecord.uid

                val principal = try {
                    val user = userRepository.readUserByUid(userRecord.uid)
                    UserPrincipal(user)
                } catch(e: UserException.UserNotFound) {
                    val user = userRepository.createUser(userRecord.uid)
                    UserPrincipal(user)
                }

                principal
            }
        }
    }
}
\end{minted}
\end{listing}

Žádné \emph{Routes} pro funkcionalitu přihlášení a registrace být definovány nemusí, jelikož tento proces bude probíhat přes \emph{Firebase} autentizaci. V~ukázce kódu \ref{code:ktor-security-config} je ale vidět, že po úspěšném ověření \emph{access tokenu} se aplikace pokusí získat objekt uživatele z~databáze, případně nového uživatele vytvořit. Tyto funkce poskytuje \texttt{UserRepository}, která bude dále definovat řadu dalších funkcích souvisejících v~práci s~daty, které se týkají uživatele. Definice rozhraní tohoto repozitáře je součástí doménové vrstvy, implementaci poté definuje datová vrstva. Implementace repozitáře poté bude potřebovat pro přístup k~datům \emph{Source}, v~tomto případě \texttt{UserSource}. Implementace tohoto \emph{Source} už poté přímo poskytuje komunikaci s~\emph{Firestore} databází.

V~ukázce kódu \ref{code:be-create-user} je vidět implementace toho, jak se v~databázi vytváří nový uživatel. Lze nahlédnout, že tato metoda vrací objekt úspěšně vytvořeného uživatele typu \texttt{FirestoreUser}. Jako parametr funkce ale bere typ \texttt{User}. \texttt{User} je totiž doménový objekt reprezentující uživatele, v~databázi se používá databázový model nazvaný \texttt{FirestoreUser}, a mezi těmito objekty existují převáděcí funkce (\texttt{toFirestore()}). Další backendovou reprezentací uživatele je pak ještě \texttt{UserDto}, která se zase používá při komunikaci s~klientem.

\begin{listing}
\caption{Vytvoření nového uživatele v~\texttt{UserSourceImpl}}\label{code:be-create-user}
\begin{minted}{Kotlin}
internal class UserSourceImpl : UserSource {

    private val db = GoogleFirestoreClient.getFirestore()
    
    // ...
    
    override suspend fun createUser(user: User): FirestoreUser {
        db
            .collection(SourceConstants.Firestore.Collection.USERS)
            .document(user.uid)
            .set(user.toFirestore())
            .await()

        return db
            .collection(SourceConstants.Firestore.Collection.USERS)
            .document(user.uid)
            .get()
            .await()
            .toObject(FirestoreUser::class.java) 
                ?: throw UserException.UserNotFound(user.uid)
    }
    
    // ...
}
\end{minted}
\end{listing}

%---------------------------------------------------------------
\subsubsection{Multi-platformní část}
%---------------------------------------------------------------

Pro potřeby přihlášení a registrace poskytuje multi-platformní knihovna následující \emph{Use Cases}:
\begin{itemize}
\item\texttt{LoginWithCredentialsUseCase} – Poskytuje přihlášení pomocí e-mailu a hesla. Tuto funkcionalitu ale implemetuje \emph{Firebase} autentizace na straně nativní aplikace, multi-platformní kód tedy musí provolat sdílený \texttt{AuthProvider}, který implementuje nativní aplikace pomocí \emph{Firebase} knihovny.
\item\texttt{RegisterUseCase} – Registruje uživatele přes \emph{Firebase} autentizaci, stejným způsobem jako přihlášení.
\item\texttt{LogoutUseCase} – Odhlásí uživatele pomocí \emph{Firebase} autentizace. Tento \emph{Use Case} sice bude potřeba až v~profilu uživatele, ale je součástí \emph{auth} modulu multi-platformní části, je zde tedy zmíněn.
\item\texttt{IsLoggedInUseCase} – Zjistí, zda je uživatel do aplikace přihlášený, nebo ne. Tento \emph{Use Case} se zavolá při čistém spuštění aplikace, aby zjistila, zda má ukázat přihlašovací obrazovku, nebo uživateli rovnou ukázat časovač. Funguje tak, že \emph{Firebase} autentizace zeptá, zda má uložený \emph{access token}.
\end{itemize}

API \emph{Firebase} knihovny je potřeba provolávat pomocí sdíleného \texttt{AuthProvider} zpět do nativní aplikace, protože \emph{Firebase} oficiálně nenabízí SDK pro \emph{Kotlin Multiplatform}, ale pouze SDK pro nativní aplikace (\emph{firebase-ios-sdk} \cite{firebase-ios-sdk} a \emph{firebase-android-sdk} \cite{firebase-android-sdk}). Existuje sice \emph{firebase-kotlin-sdk}, která podporuje \emph{Kotlin Multiplatform}, ale nejedná se o~oficiální SDK a nemá 100\% pokrytí celého \emph{Firebase} API.

Žádné z~těchto \emph{Use Cases} neprovolávají \emph{Endpoints} na backendu, ovlivňují ale to, jak budou ostatní požadavky vypadat, konkrétně obsah parametru pro autorizaci v~hlavičce požadavků.

%---------------------------------------------------------------
\subsubsection{Nativní aplikace}
%---------------------------------------------------------------

Implementace přihlášení a registrace dodržuje vzhledový návrh ze sekce \ref{feature-onboarding}. Realizace viditelná na skutečném zařízení lze vidět na obrázku \ref{fig:onboarding-impl}, kde lze i~vidět jak se rozhraní přizpůsobí vysunuté klávesnici. Na obrázku \ref{fig:login-error-impl} je také vidět, jakým způsobem ze zobrazí \emph{Toast}\footnote{\emph{Toast} je UI komponentou z~\emph{DevStack} šablony sloužící pro dočasné zobrazovaní informací nebo chybových hlášek na obrazovce.} s~chybovou hláškou.

\begin{figure}[h]
    \centering
    \begin{subfigure}[b]{0.4\textwidth}
		\centering
		\includegraphics[width=6cm]{login-error-impl.png}
		\caption{Chyba při přihlášení}
		\label{fig:login-error-impl}
	\end{subfigure}
	\hspace{2cm}
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\includegraphics[width=6cm]{register-impl.png}
		\caption{Registrace}
	\end{subfigure}
	\caption{Realizace přihlášení a registrace}
	\label{fig:onboarding-impl}
\end{figure}

%---------------------------------------------------------------
\subsection{Časovač}
%---------------------------------------------------------------

Tato funkcionalita pokrývá veškeré operace s~ovládáním časovače, získáváním historie časových záznamů a vytváření nových záznamů. Jedná se o~hlavní funkci aplikace.

%---------------------------------------------------------------
\subsubsection{Backend}
%---------------------------------------------------------------

Backednová část platformy bude muset obsluhovat veškerá data, která se týkají časovače a časových záznamů. Backend je ale rozdělený podle funkcionalit jiným způsobem, než nativní aplikace a multi-platformní část, které jsou rozděleny podle funkcionalit z~hlediska uživatele. Moduly backendu jsou rozděleny podle toho, čeho se data v~modulu týkají, tedy například klienti, projekty, integrace a uživatel. Jelikož pro data časovače budou potřeba data uživatele, u~kterého se ukládá aktuální nastavení časovače a historie časových záznamů, ale také data projektů a klientů, bude implementace funkcionality časovače zasahovat do více modulů. Největší část funkcionality časovače bude obsluhovat modul uživatele. 

Obrazovka časovače bude potřebovat následující data – souhrn odpracovaných hodin v~aktuální den a týden, historii časových záznamů, aktuální nastavení časovače a přehled projektů, bude-li si uživatel chtít vybrat projekt, který časovači přidělí.

V~první řadě je tedy potřeba implementovat získávání historie časových záznamů, protože to bude potřeba i~pro výpočet odpracovaných hodin v~aktuálním dnu a týdnu. V~návrhu v~sekci \ref{feature-timer} bylo popsáno, že načítání historie časových záznamů by mělo podporovat stránkování, jelikož může teoreticky obsahovat velké množství záznamů, a pokud by se mělo velké množství načítat celé najednou, mohlo by to trvat dlouho a mohlo by se jednat o~velké množství dat, která by ale uživatel nejspíš ani všechna vůbec nepotřeboval. \texttt{UserRepository} tedy definuje mimo jiné funkce pro získávání záznamů, které lze nahlédnout v~ukázce kódu \ref{code:be-read-entries-interface}. Tyto funkce potřebují parametr \texttt{uid} identifikující uživatele, pro kterého mají být záznamy čteny, a dále přijímají nepovinné parametry pro specifikaci toho, od kdy a do kdy mají být záznamy čteny, a kolik maximálně záznamů se ve stránce má nacházet. Pokud bude mít některý z~těchto nepovinných parametrů hodnotu \texttt{null}, nebude žádné omezení na záznamy klást. Rozdíl mezi funkcemi, které vrací stránky objektu \texttt{TimerEntry} a stránky objektu \text{TimerEntryPreview} je ten, že objekt \texttt{TimerEntryPreview} obsahuje navíc celé zdrojové objekty klienta a projektu, který k~záznamu patří, zatímco \texttt{TimerEntry} obsahuje pouze jejich identifikátory. V~obrazovce pro zobrazení historie záznamů budou tyto zdrojové objekty potřebovat, protože při jejich vizualizaci (při jejich \emph{preview}) bude potřeba zobrazit jméno klienta a projektu.

\begin{listing}
\caption{Funkce pro získávání časových záznamů v~\texttt{UserRepository}}\label{code:be-read-entries-interface}
\begin{minted}{Kotlin}
interface UserRepository {

    // ...
    
    suspend fun readEntries(
        uid: String,
        startAfter: Instant?,
        limit: Int?,
        endAt: Instant?
    ): Page<TimerEntry>
    
    // ...
    
    suspend fun readEntryPreviews(
        uid: String,
        startAfter: Instant?,
        limit: Int?,
        endAt: Instant?
    ): Page<TimerEntryPreview>
    
    // ...
}
\end{minted}
\end{listing}

V~ukázce kódu \ref{code:be-read-entries-source} lze poté vidět, jakým způsobem aplikace získává záznamy přímo z~\emph{Firestore} databáze. Omezení ve smyslu od kdy do kdy záznamy číst a kolik maximálně jich přečíst se implementuje pomocí funkcí \texttt{startAfter(start)}, \texttt{endAt(end)} a \texttt{limit(limit)}, které přímo nabízí \emph{Firestore} API. \texttt{UserRepositoryImpl} používá tuto \emph{Source} funkci i~pro načtení \emph{preview} objektů, objekty klienta a projektu si pak pomocí identifikátoru načte sama a připojí je.

\begin{listing}
\caption{Funkce pro získávání časových záznamů v~\texttt{UserSourceImpl}}\label{code:be-read-entries-source}
\begin{minted}{Kotlin}
internal class UserSourceImpl : UserSource {

    // ...
    
    override suspend fun readEntries(
        uid: String,
        startAfter: Instant?,
        limit: Int?,
        endAt: Instant?
    ): Page<FirestoreTimerEntry> {
        val entriesCollection = db
            .collection(SourceConstants.Firestore.Collection.ENTRIES)
            .document(uid)
            .collection(SourceConstants.Firestore.Collection.ENTRIES)
            .orderBy(
                SourceConstants.Firestore.FieldName.STARTED_AT, 
                Query.Direction.DESCENDING
            )

        val snapshot = entriesCollection
            .startAfter(startAfter?.toTimestamp() ?: Timestamp.now())
            .endAt(endAt?.toTimestamp() ?: Timestamp.MIN_VALUE)
            .limit(limit ?: Int.MAX_VALUE)
            .get()
            .await()

        val data = snapshot.documents.map { it.toObject(FirestoreTimerEntry::class.java) }

        val remainingCount = entriesCollection
            .startAfter(data.lastOrNull()?.startedAt ?: Timestamp.MIN_VALUE)
            .count()
            .get()
            .await()
            .count

        return Page(
            data = data,
            isLast = remainingCount == 0.toLong()
        )
    }
    
    // ...
}
\end{minted}
\end{listing}

Při načítání historie záznamů na obrazovce časovače pak bude potřeba použít parametry \texttt{startAfter}, abychom definovali datum a čas, od kterého další záznamy načítat, pokud načítáme další stránky, a \texttt{limit}, který určí velikost stránky. Při načítání všech záznamů v~nějakém období se pak využije parametrů \texttt{startAfter} a \texttt{endAt}, například když bude potřeba zjistit souhrn odpracovaných hodin v~aktuální den nebo týden. Při výpočtu tohoto souhrnu bude tedy \texttt{UserRepositoryImpl} sčítat doby trvání všech záznamů v~daném období.

Pro obsluhu časovače pak \texttt{UserRepository} poskytuje funkce pro načtení dat časovače a pro jejich aktualizaci. Při výběru projektu bude uživatel potřebovat vidět všechny své projekty a názvy jejich klientu, pro což bude sloužit opět \emph{preview} objekt \texttt{ProjectPreview}. \texttt{ClientRepository} tedy nabízí funkce pro získání klienta podle identifikátoru, a \texttt{UserRepository} nabízí funkce pro získání projektu podle identifikátoru klienta a projektu, ale také funkci pro získání všech projektů daného uživatele.

Pro komunikaci s~klientem se také využívá vlastních struktur pro reprezentaci chyb. Například modul \texttt{user} používá výjimky ze skupiny \texttt{UserExceptions}, která dědí z~třídy \texttt{BaseException}. V~případě, že některé volání vrátí výjimku s~tímto rodičem, tak ji komunikace umí zakódovat do DTO reprezentace, která je známá pro klienta. Ten může potom rozlišovat mezi různými známými chybami. V~případě, že se nejedná o~známou chybu, zakóduje ji komunikace jako obecnou chybu s~HTTP status kódem 500. Implementace tohoto chování lze nahlédnout ve výpisu kódu \ref{code:be-error-handling}.

\begin{listing}
\caption{Obsluha chyb na backendu}\label{code:be-error-handling}
\begin{minted}{Kotlin}
fun Application.configureRouting(isDebug: Boolean) {
    install(StatusPages) {
        exception<BaseException> { call, baseException ->
            call.respond(
                status = baseException.code,
                message = baseException.toDto(isDebug)
            )
        }

        exception<Throwable> { call, cause ->
            call.respond(
                status = HttpStatusCode.InternalServerError,
                message = ErrorDto(
                    type = "InternalError",
                    message = "Internal Server Error",
                    debugMessage = if (isDebug) cause.message else null
                )
            )
        }
    }
    
    // ...
}
\end{minted}
\end{listing}

%---------------------------------------------------------------
\subsubsection{Multi-platformní část}
%---------------------------------------------------------------

Multi-platformní část aplikace už rozděluje své moduly podle funkcionalit z~hlediska uživatele, modul \texttt{timer} bude tedy poskytovat všechny \emph{Use Cases} pro potřeby časovače:
\begin{itemize}
\item\texttt{AddTimerEntryUseCase} – Vytvoří nový časový záznam podle parametrů.
\item\texttt{DeleteTimerEntryUseCase} – Smaže časový záznam podle identifikátoru.
\item\texttt{GetProjectsUseCase} – Získá \emph{preview} objekty všech projektů, které má uživatel přiřazeny.
\item\texttt{GetTimerDataPreviewUseCase} – Získá \emph{preview} objekt pro aktuální nastavení časovače. Čistá data o~aktuálním stavu časovače totiž opět obsahují jen identifikátory klienta a projektu, ale při vizualizaci dat jsou potřeba jejich názvy.
\item\texttt{GetTimerEntriesUseCase} – Získává stránky \emph{preview} objektů časových záznamů, umí tedy pracovat se všemi parametry pro omezení stránky. Zároveň časové záznamy seskupuje do seznamu objektů typu \texttt{TimerEntryGroup}, což je skupina, která obsahuje datum, seznam všech záznamů patřící k~tomuto datu a součet odpracovaných hodin všech těchto záznamů. Toho se využije při vizualizaci v~nativní aplikaci, kde se nad každou skupinou ukáže datum a časový souhrn pro daný den.
\item\texttt{GetTimerSummariesUseCase} – Získá souhrny časových záznamů pro aktuální den a týden.
\item\texttt{UpdateTimerDataUseCase} – Aktualizuje aktuální nastavení časovače.
\end{itemize}

Všechny tyto \emph{Use Cases} automaticky počítají s~tím, že pracují s~daty aktuálně přihlášeného uživatele, žádné parametry pro jeho identifikaci tedy nepotřebují.

Jednotlivé \emph{Use Cases} už komunikují s~backendem, a to v~nejnižší \emph{infrastructure} vrstvě, která požadavky posílá pomocí knihovny \emph{Ktor}. Příklad toho, jak probíhá komunikace, lze nahlédnout v~ukázce kódu \ref{code:kmp-read-entries-source-impl}.

\begin{listing}
\caption{Funkce pro získávání časových záznamů v~\texttt{RemoteTimerSource}}\label{code:kmp-read-entries-source-impl}
\begin{minted}{Kotlin}
internal class RemoteTimerSource(
    private val client: HttpClient
) : TimerSource {
    override suspend fun readEntries(
        startAfter: String?,
        limit: Int?,
        endAt: String?
    ): Result<PageDto<TimerEntryDto>> =
        runCatchingCommonNetworkExceptions {
            val res = client.get("user/entries") {
                url {
                    startAfter?.let { parameters.append("startAfter", it) }
                    limit?.let { parameters.append("limit", it.toString()) }
                    endAt?.let { parameters.append("endAt", it) }
                }
            }
            res.body<PageDto<TimerEntryDto>>()
        }
        
    // ...
}
\end{minted}
\end{listing}

Multi-platformní část pracuje s~objekty v~DTO reprezentaci, kterou definuje backend. Poté si je také převádí pomocí vlastních funkcí do vlastních doménových reprezentací.

Také lze ve výpisu kódu \ref{code:kmp-read-entries-source-impl} nahlédnout, že celé API volání je obaleno do pomocné funkce \texttt{runCatchingCommonNetworkExceptions}, jejíž implementace lze nahlédnout ve výpisu \ref{code:kmp-run-catching-common-network-exceptions}. Tato funkce odchytává všechny výjimky, které při komunikaci s~backendem mohou vzniknout, a převádí je do vlastních reprezentací, se kterými poté umí pracovat nativní aplikace.

\begin{listing}
\caption{Odchytávání výjimek při komunikaci s~backendem}\label{code:kmp-run-catching-common-network-exceptions}
\begin{minted}{Kotlin}
internal suspend inline fun <R : Any> runCatchingCommonNetworkExceptions(
    block: () -> R
): Result<R> =
    try {
        Result.Success(block())
    } catch (e: ResponseException) {
        val body = e.response.body<ErrorDto>()

        when (body.type) {
            "Unauthorized" -> Result.Error(
                BackendError.NotAuthorized(e.response.toString(), e),
            )

            "ProjectNotAssignedToUser" -> Result.Error(
                BackendError.ProjectNotAssignedToUser(e.message, e)
            )

            "MissingProject" -> Result.Error(
                BackendError.MissingProject(e.message, e)
            )

            "ProjectNotFound" -> Result.Error(
                BackendError.ProjectNotFound(e.message, e)
            )

            "ClientNotFound" -> Result.Error(
                BackendError.ClientNotFound(e.message, e)
            )

            else -> Result.Error(
                ErrorResult(
                    message = body.message,
                    throwable = e
                )
            )
        }
    } catch (e: Throwable) {
        Result.Error(handlePlatformError(e))
    }
\end{minted}
\end{listing}

%---------------------------------------------------------------
\subsubsection{Nativní aplikace}
%---------------------------------------------------------------

%---------------------------------------------------------------
\subsection{Profil uživatele}
%---------------------------------------------------------------

%---------------------------------------------------------------
\subsubsection{Nativní aplikace}
%---------------------------------------------------------------

%---------------------------------------------------------------
\subsubsection{Multi-platformní část}
%---------------------------------------------------------------

%---------------------------------------------------------------
\subsubsection{Backend}
%---------------------------------------------------------------

%---------------------------------------------------------------
\subsection{Integrace}
%---------------------------------------------------------------

%---------------------------------------------------------------
\subsubsection{Nativní aplikace}
%---------------------------------------------------------------

%---------------------------------------------------------------
\subsubsection{Multi-platformní část}
%---------------------------------------------------------------

%---------------------------------------------------------------
\subsubsection{Backend}
%---------------------------------------------------------------
